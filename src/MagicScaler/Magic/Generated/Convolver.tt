<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#
procDef[] ta = {
	new procDef {
		name = "Bgra",
		suffix = "Byte",
		channels = 4,
		alpha = true,
		sharpen = true,
		pixelType = "byte",
		interType = "int",
		weighType = "int",
		xUnroll = 4,
		yUnroll = 2
	},
	new procDef {
		name = "Bgra",
		suffix = "UQ15",
		channels = 4,
		alpha = true,
		sharpen = true,
		pixelType = "ushort",
		interType = "int",
		weighType = "int",
		xUnroll = 4,
		yUnroll = 2
	},
	new procDef {
		name = "4Chan",
		suffix = "Byte",
		channels = 4,
		sharpen = true,
		pixelType = "byte",
		interType = "int",
		weighType = "int",
		xUnroll = 4,
		yUnroll = 2
	},
	new procDef {
		name = "4Chan",
		suffix = "UQ15",
		channels = 4,
		sharpen = true,
		pixelType = "ushort",
		interType = "int",
		weighType = "int",
		xUnroll = 4,
		yUnroll = 2
	},
	new procDef {
		name = "Bgr",
		suffix = "Byte",
		channels = 3,
		sharpen = true,
		pixelType = "byte",
		interType = "int",
		weighType = "int",
		xUnroll = 5,
		yUnroll = 2
	},
	new procDef {
		name = "Bgr",
		suffix = "UQ15",
		channels = 3,
		sharpen = true,
		pixelType = "ushort",
		interType = "int",
		weighType = "int",
		xUnroll = 5,
		yUnroll = 2
	},
	new procDef {
		name = "2Chan",
		suffix = "Byte",
		channels = 2,
		pixelType = "byte",
		interType = "int",
		weighType = "int",
		xUnroll = 8,
		yUnroll = 4
	},
	new procDef {
		name = "1Chan",
		suffix = "Byte",
		channels = 1,
		sharpen = true,
		pixelType = "byte",
		interType = "int",
		weighType = "int",
		xUnroll = 8,
		yUnroll = 4
	},
	new procDef {
		name = "1Chan",
		suffix = "UQ15",
		channels = 1,
		sharpen = true,
		pixelType = "ushort",
		interType = "int",
		weighType = "int",
		xUnroll = 8,
		yUnroll = 4
	}
};
#>
//------------------------------------------------------------------------------
//	<auto-generated>
//		This code was generated from a template.
//		Manual changes to this file will be overwritten if the code is regenerated.
//	</auto-generated>
//------------------------------------------------------------------------------

using System;

using static PhotoSauce.MagicScaler.MathUtil;

namespace PhotoSauce.MagicScaler
{
<#
foreach (var t in ta) {
	if (t != ta[0]) WriteLine(null);
#>
	unsafe internal sealed class Convolver<#= t.name #><#= t.suffix #> : IConvolver
	{
		private const int Channels = <#= t.channels #>;

		int IConvolver.Channels => Channels;
		int IConvolver.MapChannels => 1;

		void IConvolver.ConvolveSourceLine(byte* istart, byte* tstart, int cb, byte* mapxstart, int smapx, int smapy)
		{
			<#= t.weighType #>* pmapx = (<#= t.weighType #>*)mapxstart;
			<#= t.interType #>* tp = (<#= t.interType #>*)tstart;
			<#= t.interType #>* tpe = (<#= t.interType #>*)(tstart + cb);
			int tstride = smapy * Channels;

			while (tp < tpe)
			{
				<#= t.interType #><# for (int j = 0; j < t.channels - (t.alpha ? 1 : 0); j++) {#><#= j > 0 ? "," : "" #> a<#= j #> = 0<# } if (t.alpha) { #>, aa = 0, aw = 0<# } #>;

				int ix = *<#= t.weighType == "int" ? "" : "(int*)" #>pmapx++;
				<#= t.pixelType #>* ip = <#= t.pixelType != "byte" ? $"({t.pixelType}*)" : "" #>istart + ix * Channels + <#= t.xUnroll #> * Channels;
				<#= t.pixelType #>* ipe = ip + smapx * Channels - <#= t.xUnroll > 2 ? $"{(t.xUnroll - 1)} * " : "" #>Channels;
				<#= t.weighType #>* mp = pmapx + <#= t.xUnroll #>;
				pmapx += smapx;

				while (ip < ipe)
				{
<#
for (int i = 0; i < t.xUnroll; i++) {
	if (t.channels == 1) {
#>
					a0 += ip[<#= i - t.xUnroll #>] * mp[<#= i - t.xUnroll #>];
<#
	} else {
		if (t.alpha) {
#>
					<#= i == 0 ? "int " : "" #>alpha = ip[<#= (i - t.xUnroll) * t.channels + t.channels - 1 #>];
					<#= i == 0 ? "int " : "" #>w = mp[<#= (i - t.xUnroll) #>];

					aa += alpha * w;
					if (alpha < <#= t.suffix == "UQ15" ? "UQ15One" : "255" #>)
					{
						int pw = UnFix15(w * alpha<#= t.suffix == "UQ15" ? "" : " << 7" #>);
						aw += w - pw;
						w = pw;
					}

					if (w != 0)
					{
<#
			PushIndent("\t");
		}
		if (!t.alpha) {
#>
					<#= i == 0 ? "int " : "" #>w = mp[<#= (i - t.xUnroll) #>];
<#
		}
		for (int j = 0; j < t.channels - (t.alpha ? 1 : 0); j++) {
#>
					a<#= j #> += ip[<#= (i - t.xUnroll) * t.channels + j #>] * w;
<#
		}
		if (t.alpha) {
			PopIndent();
#>
					}
<#
		}
		WriteLine(null);
	}
}
#>
					ip += <#= t.xUnroll #> * Channels;
					mp += <#= t.xUnroll #>;
				}

<#
if (t.xUnroll > 1) {
#>
				ip -= <#= t.xUnroll > 2 ? $"{(t.xUnroll - 1)} * " : "" #>Channels;
				mp<#= t.xUnroll > 2 ? $" -= {(t.xUnroll - 1)}" : "--" #>;
				while (ip < ipe)
				{
<#
	if (t.channels == 1) {
#>
					a0 += ip[-1] * mp[-1];
<#
	} else {
		if (t.alpha) {
#>
					int alpha = ip[<#= -t.channels + t.channels - 1 #>];
					int w = mp[-1];

					aa += alpha * w;
					if (alpha < <#= t.suffix == "UQ15" ? "UQ15One" : "255" #>)
					{
						int pw = UnFix15(w * alpha<#= t.suffix == "UQ15" ? "" : " << 7" #>);
						aw += w - pw;
						w = pw;
					}

					if (w != 0)
					{
<#
			PushIndent("\t");
		}
		if (!t.alpha) {
#>
					int w = mp[-1];
<#
		}
		for (int j = 0; j < t.channels - (t.alpha ? 1 : 0); j++) {
#>
					a<#= j #> += ip[<#= -t.channels + j #>] * w;
<#
		}
		if (t.alpha) {
			PopIndent();
#>
					}
<#
		}
	}
#>

					ip += Channels;
					mp++;
				}

<#
	if (t.alpha) {
#>
				if (aw != 0)
				{
					int wf = aw == UQ15One ? UQ15One : ((UQ15One << 15) / (UQ15One - aw));
<#
		for (int j = 0; j < t.channels - 1; j++) {
#>
					a<#= j #> = UnFix15(a<#= j #>) * wf;
<#
		}
#>
				}

<#
	}
}
for (int j = 0; j < t.channels - (t.alpha ? 1 : 0); j++) {
#>
				tp[<#= j #>] = UnFix15(a<#= j #>);
<#
}
if (t.alpha) {
#>
				tp[<#= t.channels - 1 #>] = UnFix15(aa);
<#
}
#>
				tp += tstride;
			}
		}

		void IConvolver.WriteDestLine(byte* tstart, byte* ostart, int ox, int ow, byte* pmapy, int smapy)
		{
			<#= t.pixelType #>* op = <#= t.pixelType != "byte" ? $"({t.pixelType}*)" : "" #>ostart;
			int xc = ox + ow, tstride = smapy * Channels;

			while (ox < xc)
			{
				<#= t.interType #><# for (int j = 0; j < t.channels - (t.alpha ? 1 : 0); j++) {#><#= j > 0 ? "," : "" #> a<#= j #> = 0<# } if (t.alpha) { #>, aa = 0, aw = 0<# } #>;

				<#= t.interType #>* tp = (<#= t.interType #>*)tstart + ox * tstride + <#= t.yUnroll #> * Channels;
				<#= t.interType #>* tpe = tp + tstride - <#= t.yUnroll > 2 ? $"{(t.yUnroll - 1)} * " : "" #>Channels;
				<#= t.weighType #>* mp = (<#= t.weighType #>*)pmapy + <#= t.yUnroll #>;

				while (tp < tpe)
				{
<#
for (int i = 0; i < t.yUnroll; i++) {
	if (t.channels == 1) {
#>
					a0 += tp[<#= i - t.yUnroll #>] * mp[<#= i - t.yUnroll #>];
<#
	} else {
		if (t.alpha) {
#>
					<#= i == 0 ? "int " : "" #>alpha = tp[<#= (i - t.yUnroll) * t.channels + t.channels - 1 #>];
					<#= i == 0 ? "int " : "" #>w = mp[<#= (i - t.yUnroll) #>];

					aa += alpha * w;
					if (alpha < <#= t.suffix == "UQ15" ? "UQ15One" : "255" #>)
					{
						int pw = UnFix15(w * alpha<#= t.suffix == "UQ15" ? "" : " << 7" #>);
						aw += w - pw;
						w = pw;
					}

					if (w != 0)
					{
<#
			PushIndent("\t");
		}
		if (!t.alpha) {
#>
					<#= i == 0 ? "int " : "" #>w = mp[<#= (i - t.yUnroll) #>];
<#
		}
		for (int j = 0; j < t.channels - (t.alpha ? 1 : 0); j++) {
#>
					a<#= j #> += tp[<#= (i - t.yUnroll) * t.channels + j #>] * w;
<#
		}
		if (t.alpha) {
			PopIndent();
#>
					}
<#
		}
		WriteLine(null);
	}
}
#>
					tp += <#= t.yUnroll #> * Channels;
					mp += <#= t.yUnroll #>;
				}

<#
if (t.yUnroll > 1) {
#>
				tp -= <#= t.yUnroll > 2 ? $"{(t.yUnroll - 1)} * " : "" #>Channels;
				mp<#= t.yUnroll > 2 ? $" -= {(t.yUnroll - 1)}" : "--" #>;
				while (tp < tpe)
				{
<#
	if (t.channels == 1) {
#>
					a0 += tp[-1] * mp[-1];
<#
	} else {
		if (t.alpha) {
#>
					int alpha = tp[<#= -t.channels + t.channels - 1 #>];
					int w = mp[-1];

					aa += alpha * w;
					if (alpha < <#= t.suffix == "UQ15" ? "UQ15One" : "255" #>)
					{
						int pw = UnFix15(w * alpha<#= t.suffix == "UQ15" ? "" : " << 7" #>);
						aw += w - pw;
						w = pw;
					}

					if (w != 0)
					{
<#
			PushIndent("\t");
		}
		if (!t.alpha) {
#>
					int w = mp[-1];
<#
		}
		for (int j = 0; j < t.channels - (t.alpha ? 1 : 0); j++) {
#>
					a<#= j #> += tp[<#= -t.channels + j #>] * w;
<#
		}
		if (t.alpha) {
			PopIndent();
#>
					}
<#
		}
	}
#>

					tp += Channels;
					mp++;
				}

<#
}
if (t.alpha)
{
#>
				if (aa <= UQ15Round)
				{
					<# for (int j = 0; j < t.channels - 1; j++) { #>a<#= j #> = <# } #>aa = 0;
				}
				else if (aw != 0)
				{
					int wf = aw == UQ15One ? UQ15One : ((UQ15One << 15) / (UQ15One - aw));
<#
		for (int j = 0; j < t.channels - 1; j++) {
#>
					a<#= j #> = UnFix15(a<#= j #>) * wf;
<#
		}
#>
				}

<#
}
for (int j = 0; j < t.channels - (t.alpha ? 1 : 0); j++) {
#>
				op[<#= j #>] = UnFix<#= t.pixelType == "byte" ? "15" : "" #>To<#= t.suffix #>(a<#= j #>);
<#
}
if (t.alpha) {
#>
				op[<#= t.channels - 1 #>] = UnFix<#= t.pixelType == "byte" ? "15" : "" #>To<#= t.suffix #>(aa);
<#
}
#>
				op += Channels;
				ox++;
			}
		}

<#
//http://en.wikipedia.org/wiki/Unsharp_masking
if (t.sharpen) {
#>
		void IConvolver.SharpenLine(byte* cstart, byte* ystart, byte* bstart, byte* ostart, int ox, int ow, int amt, int thresh, bool gamma)
		{
<#
if (t.pixelType == "ushort") {
#>
			fixed (byte* gtstart = &LookupTables.SrgbGamma[0])
			fixed (ushort* igtstart = &LookupTables.SrgbInverseGammaUQ15[0])
			{
<#
	PushIndent("\t");
}
#>
			<#= t.interType #> iamt = Fix15(amt * 0.01);
			<#= t.interType #> threshold = thresh;
<#
WriteLine(null);
if (t.pixelType == "ushort") {
#>
			byte* gt = gtstart;
<#
}
#>
			<#= t.pixelType #>* ip = <#= t.pixelType != "byte" ? $"({t.pixelType}*)" : "" #>cstart, yp = <#= t.pixelType != "byte" ? $"({t.pixelType}*)" : "" #>ystart, bp = <#= t.pixelType != "byte" ? $"({t.pixelType}*)" : "" #>bstart, op = <#= t.pixelType != "byte" ? $"({t.pixelType}*)" : "" #>ostart<#= t.pixelType == "ushort" ? ", igt = igtstart" : "" #>;
<#
WriteLine(null);
#>
			int xc = ox + ow;
			for (int x = ox; x < xc; x++, ip += Channels, op += Channels)
			{
				<#= t.interType #> dif = *yp++ - *bp++;
<#
WriteLine(null);
#>
				<#= t.pixelType #><# for (int j = 0; j < t.channels; j++) { #><#= j > 0 ? "," : "" #> c<#= j #> = ip[<#= j #>]<# } #>;
				if (threshold == 0 || Math.Abs(dif) > threshold)
				{
					dif = UnFix15(dif * iamt);
<#
for (int j = 0; j < t.channels - (t.alpha || t.channels == 4 ? 1 : 0); j++) {
#>
					op[<#= j #>] = <#= t.pixelType == "ushort" ? "igt[" : "" #>ClampToByte(<#= t.pixelType == "ushort" ? "gt[" : "" #>c<#= j #><#= t.pixelType == "ushort" ? "]" : "" #> + dif)<#= t.pixelType == "ushort" ? "]" : "" #>;
<#
}
if (t.alpha || t.channels == 4) {
#>
					op[<#= t.channels - 1 #>] = c<#= t.channels - 1 #>;
<#
}
#>
				}
				else
				{
<#
for (int j = 0; j < t.channels; j++) {
#>
					op[<#= j #>] = c<#= j #>;
<#
}
#>
				}
			}
<#
if (t.pixelType == "ushort") {
	PopIndent();
#>
			}
<#
}
#>
		}
<#
} else {
#>
		void IConvolver.SharpenLine(byte* cstart, byte* ystart, byte* bstart, byte* ostart, int ox, int ow, int amt, int thresh, bool gamma) => throw new NotImplementedException();
<#
}
#>
	}
<#
}
#>
}
<#+
class procDef
{
	public string name;
	public string suffix;
	public int channels;
	public bool alpha;
	public bool sharpen;
	public string pixelType;
	public string interType;
	public string weighType;
	public int xUnroll;
	public int yUnroll;
}
#>