//------------------------------------------------------------------------------
//	<auto-generated>
//		This code was generated from a template.
//		Manual changes to this file will be overwritten if the code is regenerated.
//	</auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Numerics;
using System.Runtime.CompilerServices;

using VectorF = System.Numerics.Vector<float>;

namespace PhotoSauce.MagicScaler
{
	internal sealed class Convolver4ChanFloat : IConvolver
	{
		private const int Channels = 4;

		public static Convolver4ChanFloat Instance = new Convolver4ChanFloat();

		private Convolver4ChanFloat() { }

		int IConvolver.Channels => Channels;
		int IConvolver.MapChannels => Channels;

		unsafe void IConvolver.ConvolveSourceLine(byte* istart, byte* tstart, int cb, byte* mapxstart, int smapx, int smapy)
		{
			float* tp = (float*)tstart, tpe = (float*)(tstart + cb);
			float* pmapx = (float*)mapxstart;
			int kstride = smapx * Channels;
			int tstride = smapy * Channels;

			while (tp < tpe)
			{
				int ix = *(int*)pmapx++;
				float* ip = (float*)istart + ix * Channels, ipe = ip + kstride;
				float* mp = pmapx;
				pmapx += kstride;

				float a0, a1, a2, a3;

				if (kstride >= VectorF.Count * 4)
				{
					VectorF av0 = VectorF.Zero;
					ipe -= VectorF.Count * 4;

					do
					{
						var iv0 = Unsafe.ReadUnaligned<VectorF>(ip);
						var iv1 = Unsafe.ReadUnaligned<VectorF>(ip + VectorF.Count);
						var iv2 = Unsafe.ReadUnaligned<VectorF>(ip + VectorF.Count * 2);
						var iv3 = Unsafe.ReadUnaligned<VectorF>(ip + VectorF.Count * 3);

						var mv0 = Unsafe.ReadUnaligned<VectorF>(mp);
						var mv1 = Unsafe.ReadUnaligned<VectorF>(mp + VectorF.Count);
						var mv2 = Unsafe.ReadUnaligned<VectorF>(mp + VectorF.Count * 2);
						var mv3 = Unsafe.ReadUnaligned<VectorF>(mp + VectorF.Count * 3);

						av0 += iv0 * mv0;
						av0 += iv1 * mv1;
						av0 += iv2 * mv2;
						av0 += iv3 * mv3;

						ip += VectorF.Count * 4;
						mp += VectorF.Count * 4;
					} while (ip <= ipe);

					ipe += VectorF.Count * 4;

					a0 = av0[0];
					a1 = av0[1];
					a2 = av0[2];
					a3 = av0[3];

					if (VectorF.Count == 8)
					{
						a0 += av0[4];
						a1 += av0[5];
						a2 += av0[6];
						a3 += av0[7];
					}
				}
				else
				{
					a0 = a1 = a2 = a3 = 0f;
				}

				while (ip < ipe)
				{
					a0 += ip[0] * mp[0];
					a1 += ip[1] * mp[1];
					a2 += ip[2] * mp[2];
					a3 += ip[3] * mp[3];

					ip += Channels;
					mp += Channels;
				}

				tp[0] = a0;
				tp[1] = a1;
				tp[2] = a2;
				tp[3] = a3;
				tp += tstride;
			}
		}

		unsafe void IConvolver.WriteDestLine(byte* tstart, byte* ostart, int ox, int ow, byte* pmapy, int smapy)
		{
			float* op = (float*)ostart;
			int xc = ox + ow, tstride = smapy * Channels;

			while (ox < xc)
			{
				float* tp = (float*)tstart + ox * tstride, tpe = tp + tstride;
				float* mp = (float*)pmapy;

				float a0, a1, a2, a3;

				if (tstride >= VectorF.Count * 4)
				{
					VectorF av0 = VectorF.Zero;
					tpe -= VectorF.Count * 4;

					do
					{
						var tv0 = Unsafe.ReadUnaligned<VectorF>(tp);
						var tv1 = Unsafe.ReadUnaligned<VectorF>(tp + VectorF.Count);
						var tv2 = Unsafe.ReadUnaligned<VectorF>(tp + VectorF.Count * 2);
						var tv3 = Unsafe.ReadUnaligned<VectorF>(tp + VectorF.Count * 3);

						var mv0 = Unsafe.ReadUnaligned<VectorF>(mp);
						var mv1 = Unsafe.ReadUnaligned<VectorF>(mp + VectorF.Count);
						var mv2 = Unsafe.ReadUnaligned<VectorF>(mp + VectorF.Count * 2);
						var mv3 = Unsafe.ReadUnaligned<VectorF>(mp + VectorF.Count * 3);

						av0 += tv0 * mv0;
						av0 += tv1 * mv1;
						av0 += tv2 * mv2;
						av0 += tv3 * mv3;

						tp += VectorF.Count * 4;
						mp += VectorF.Count * 4;
					} while (tp <= tpe);

					tpe += VectorF.Count * 4;

					a0 = av0[0];
					a1 = av0[1];
					a2 = av0[2];
					a3 = av0[3];

					if (VectorF.Count == 8)
					{
						a0 += av0[4];
						a1 += av0[5];
						a2 += av0[6];
						a3 += av0[7];
					}
				}
				else
				{
					a0 = a1 = a2 = a3 = 0f;
				}

				while (tp < tpe)
				{
					a0 += tp[0] * mp[0];
					a1 += tp[1] * mp[1];
					a2 += tp[2] * mp[2];
					a3 += tp[3] * mp[3];

					tp += Channels;
					mp += Channels;
				}

				op[0] = a0;
				op[1] = a1;
				op[2] = a2;
				op[3] = a3;
				op += Channels;
				ox++;
			}
		}

		unsafe void IConvolver.SharpenLine(byte* cstart, byte* ystart, byte* bstart, byte* ostart, int ox, int ow, int amt, int thresh, bool gamma)
		{
			float famt = amt * 0.01f;
			float threshold = (float)thresh / byte.MaxValue;

			float* ip = (float*)cstart + ox * Channels, yp = (float*)ystart + ox, bp = (float*)bstart, op = (float*)ostart;
			float* ipe = ip + ow * Channels;

			var vmin = Vector4.Zero;
			var vamt = new Vector4(famt);
			vamt.W = 0f;

			while (ip < ipe)
			{
				float dif = *yp++ - *bp++;
				var c0 = Unsafe.ReadUnaligned<Vector4>(ip);

				if (threshold == 0 || Math.Abs(dif) > threshold)
				{
					var vd = new Vector4(dif) * vamt;

					if (gamma)
					{
						c0 = Vector4.SquareRoot(Vector4.Max(c0, vmin));
						c0 = Vector4.Max(c0 + vd, vmin);
						c0 *= c0;
					}
					else
					{
						c0 += vd;
					}
				}

				Unsafe.WriteUnaligned(op, c0);

				ip += Channels;
				op += Channels;
			}
		}
	}

	internal sealed class Convolver3ChanFloat : IConvolver
	{
		private const int Vector4Count = 4;

		private const int Channels = 3;

		public static Convolver3ChanFloat Instance = new Convolver3ChanFloat();

		private Convolver3ChanFloat() { }

		int IConvolver.Channels => Channels;
		int IConvolver.MapChannels => Channels;

		unsafe void IConvolver.ConvolveSourceLine(byte* istart, byte* tstart, int cb, byte* mapxstart, int smapx, int smapy)
		{
			float* tp = (float*)tstart, tpe = (float*)(tstart + cb);
			float* pmapx = (float*)mapxstart;
			int kstride = smapx * Channels;
			int tstride = smapy * 4;

			while (tp < tpe)
			{
				int ix = *(int*)pmapx++;
				float* ip = (float*)istart + ix * Channels, ipe = ip + kstride;
				float* mp = pmapx;
				pmapx += kstride;

				float a0, a1, a2;

				if (kstride >= Vector4Count * 3)
				{
					Vector4 av0 = Vector4.Zero, av1 = av0, av2 = av0;
					ipe -= Vector4Count * 3;

					do
					{
						var iv0 = Unsafe.ReadUnaligned<Vector4>(ip);
						var iv1 = Unsafe.ReadUnaligned<Vector4>(ip + Vector4Count);
						var iv2 = Unsafe.ReadUnaligned<Vector4>(ip + Vector4Count * 2);

						var mv0 = Unsafe.ReadUnaligned<Vector4>(mp);
						var mv1 = Unsafe.ReadUnaligned<Vector4>(mp + Vector4Count);
						var mv2 = Unsafe.ReadUnaligned<Vector4>(mp + Vector4Count * 2);

						av0 += iv0 * mv0;
						av1 += iv1 * mv1;
						av2 += iv2 * mv2;

						ip += Vector4Count * 3;
						mp += Vector4Count * 3;
					} while (ip <= ipe);

					ipe += Vector4Count * 3;

					a0 = av0.X + av0.W + av1.Z + av2.Y;
					a1 = av0.Y + av1.X + av1.W + av2.Z;
					a2 = av0.Z + av1.Y + av2.X + av2.W;
				}
				else
				{
					a0 = a1 = a2 = 0f;
				}

				while (ip < ipe)
				{
					a0 += ip[0] * mp[0];
					a1 += ip[1] * mp[1];
					a2 += ip[2] * mp[2];

					ip += Channels;
					mp += Channels;
				}

				tp[0] = a0;
				tp[1] = a1;
				tp[2] = a2;
				tp += tstride;
			}
		}

		unsafe void IConvolver.WriteDestLine(byte* tstart, byte* ostart, int ox, int ow, byte* pmapy, int smapy) => throw new NotImplementedException();

		unsafe void IConvolver.SharpenLine(byte* cstart, byte* ystart, byte* bstart, byte* ostart, int ox, int ow, int amt, int thresh, bool gamma) => throw new NotImplementedException();
	}

	internal sealed class Convolver3XChanFloat : IConvolver
	{
		private const int Channels = 4;

		public static Convolver3XChanFloat Instance = new Convolver3XChanFloat();

		private Convolver3XChanFloat() { }

		int IConvolver.Channels => Channels;
		int IConvolver.MapChannels => Channels;

		unsafe void IConvolver.ConvolveSourceLine(byte* istart, byte* tstart, int cb, byte* mapxstart, int smapx, int smapy)
		{
			float* tp = (float*)tstart, tpe = (float*)(tstart + cb);
			float* pmapx = (float*)mapxstart;
			int kstride = smapx * Channels;
			int tstride = smapy * Channels;

			while (tp < tpe)
			{
				int ix = *(int*)pmapx++;
				float* ip = (float*)istart + ix * Channels, ipe = ip + kstride;
				float* mp = pmapx;
				pmapx += kstride;

				float a0, a1, a2;

				if (kstride >= VectorF.Count * 4)
				{
					VectorF av0 = VectorF.Zero;
					ipe -= VectorF.Count * 4;

					do
					{
						var iv0 = Unsafe.ReadUnaligned<VectorF>(ip);
						var iv1 = Unsafe.ReadUnaligned<VectorF>(ip + VectorF.Count);
						var iv2 = Unsafe.ReadUnaligned<VectorF>(ip + VectorF.Count * 2);
						var iv3 = Unsafe.ReadUnaligned<VectorF>(ip + VectorF.Count * 3);

						var mv0 = Unsafe.ReadUnaligned<VectorF>(mp);
						var mv1 = Unsafe.ReadUnaligned<VectorF>(mp + VectorF.Count);
						var mv2 = Unsafe.ReadUnaligned<VectorF>(mp + VectorF.Count * 2);
						var mv3 = Unsafe.ReadUnaligned<VectorF>(mp + VectorF.Count * 3);

						av0 += iv0 * mv0;
						av0 += iv1 * mv1;
						av0 += iv2 * mv2;
						av0 += iv3 * mv3;

						ip += VectorF.Count * 4;
						mp += VectorF.Count * 4;
					} while (ip <= ipe);

					ipe += VectorF.Count * 4;

					a0 = av0[0];
					a1 = av0[1];
					a2 = av0[2];

					if (VectorF.Count == 8)
					{
						a0 += av0[4];
						a1 += av0[5];
						a2 += av0[6];
					}
				}
				else
				{
					a0 = a1 = a2 = 0f;
				}

				while (ip < ipe)
				{
					a0 += ip[0] * mp[0];
					a1 += ip[1] * mp[1];
					a2 += ip[2] * mp[2];

					ip += Channels;
					mp += Channels;
				}

				tp[0] = a0;
				tp[1] = a1;
				tp[2] = a2;
				tp += tstride;
			}
		}

		unsafe void IConvolver.WriteDestLine(byte* tstart, byte* ostart, int ox, int ow, byte* pmapy, int smapy)
		{
			float* op = (float*)ostart;
			int xc = ox + ow, tstride = smapy * Channels;

			while (ox < xc)
			{
				float* tp = (float*)tstart + ox * tstride, tpe = tp + tstride;
				float* mp = (float*)pmapy;

				float a0, a1, a2;

				if (tstride >= VectorF.Count * 4)
				{
					VectorF av0 = VectorF.Zero;
					tpe -= VectorF.Count * 4;

					do
					{
						var tv0 = Unsafe.ReadUnaligned<VectorF>(tp);
						var tv1 = Unsafe.ReadUnaligned<VectorF>(tp + VectorF.Count);
						var tv2 = Unsafe.ReadUnaligned<VectorF>(tp + VectorF.Count * 2);
						var tv3 = Unsafe.ReadUnaligned<VectorF>(tp + VectorF.Count * 3);

						var mv0 = Unsafe.ReadUnaligned<VectorF>(mp);
						var mv1 = Unsafe.ReadUnaligned<VectorF>(mp + VectorF.Count);
						var mv2 = Unsafe.ReadUnaligned<VectorF>(mp + VectorF.Count * 2);
						var mv3 = Unsafe.ReadUnaligned<VectorF>(mp + VectorF.Count * 3);

						av0 += tv0 * mv0;
						av0 += tv1 * mv1;
						av0 += tv2 * mv2;
						av0 += tv3 * mv3;

						tp += VectorF.Count * 4;
						mp += VectorF.Count * 4;
					} while (tp <= tpe);

					tpe += VectorF.Count * 4;

					a0 = av0[0];
					a1 = av0[1];
					a2 = av0[2];

					if (VectorF.Count == 8)
					{
						a0 += av0[4];
						a1 += av0[5];
						a2 += av0[6];
					}
				}
				else
				{
					a0 = a1 = a2 = 0f;
				}

				while (tp < tpe)
				{
					a0 += tp[0] * mp[0];
					a1 += tp[1] * mp[1];
					a2 += tp[2] * mp[2];

					tp += Channels;
					mp += Channels;
				}

				op[0] = a0;
				op[1] = a1;
				op[2] = a2;
				op += Channels;
				ox++;
			}
		}

		unsafe void IConvolver.SharpenLine(byte* cstart, byte* ystart, byte* bstart, byte* ostart, int ox, int ow, int amt, int thresh, bool gamma)
		{
			float famt = amt * 0.01f;
			float threshold = (float)thresh / byte.MaxValue;

			float* ip = (float*)cstart + ox * Channels, yp = (float*)ystart + ox, bp = (float*)bstart, op = (float*)ostart;
			float* ipe = ip + ow * Channels;

			var vmin = Vector4.Zero;
			var vamt = new Vector4(famt);
			vamt.W = 0f;

			while (ip < ipe)
			{
				float dif = *yp++ - *bp++;
				var c0 = Unsafe.ReadUnaligned<Vector4>(ip);

				if (threshold == 0 || Math.Abs(dif) > threshold)
				{
					var vd = new Vector4(dif) * vamt;

					if (gamma)
					{
						c0 = Vector4.SquareRoot(Vector4.Max(c0, vmin));
						c0 = Vector4.Max(c0 + vd, vmin);
						c0 *= c0;
					}
					else
					{
						c0 += vd;
					}
				}

				Unsafe.WriteUnaligned(op, c0);

				ip += Channels;
				op += Channels;
			}
		}
	}

	internal sealed class Convolver1ChanFloat : IConvolver
	{
		private const int Channels = 1;

		public static Convolver1ChanFloat Instance = new Convolver1ChanFloat();

		private Convolver1ChanFloat() { }

		int IConvolver.Channels => Channels;
		int IConvolver.MapChannels => Channels;

		unsafe void IConvolver.ConvolveSourceLine(byte* istart, byte* tstart, int cb, byte* mapxstart, int smapx, int smapy)
		{
			float* tp = (float*)tstart, tpe = (float*)(tstart + cb);
			float* pmapx = (float*)mapxstart;
			int kstride = smapx * Channels;
			int tstride = smapy * Channels;

			var m0 = VectorF.One;

			while (tp < tpe)
			{
				int ix = *(int*)pmapx++;
				float* ip = (float*)istart + ix * Channels, ipe = ip + kstride;
				float* mp = pmapx;
				pmapx += kstride;

				float a0;

				if (kstride >= VectorF.Count)
				{
					VectorF av0 = VectorF.Zero;
					ipe -= VectorF.Count;

					do
					{
						var iv0 = Unsafe.ReadUnaligned<VectorF>(ip);

						var mv0 = Unsafe.ReadUnaligned<VectorF>(mp);

						av0 += iv0 * mv0;

						ip += VectorF.Count;
						mp += VectorF.Count;
					} while (ip <= ipe);

					ipe += VectorF.Count;

					a0 = Vector.Dot(av0, m0);
				}
				else
				{
					a0 = 0f;
				}

				while (ip < ipe)
				{
					a0 += ip[0] * mp[0];

					ip += Channels;
					mp += Channels;
				}

				tp[0] = a0;
				tp += tstride;
			}
		}

		unsafe void IConvolver.WriteDestLine(byte* tstart, byte* ostart, int ox, int ow, byte* pmapy, int smapy)
		{
			float* op = (float*)ostart;
			int xc = ox + ow, tstride = smapy * Channels;

			var m0 = VectorF.One;

			while (ox < xc)
			{
				float* tp = (float*)tstart + ox * tstride, tpe = tp + tstride;
				float* mp = (float*)pmapy;

				float a0;

				if (tstride >= VectorF.Count)
				{
					VectorF av0 = VectorF.Zero;
					tpe -= VectorF.Count;

					do
					{
						var tv0 = Unsafe.ReadUnaligned<VectorF>(tp);

						var mv0 = Unsafe.ReadUnaligned<VectorF>(mp);

						av0 += tv0 * mv0;

						tp += VectorF.Count;
						mp += VectorF.Count;
					} while (tp <= tpe);

					tpe += VectorF.Count;

					a0 = Vector.Dot(av0, m0);
				}
				else
				{
					a0 = 0f;
				}

				while (tp < tpe)
				{
					a0 += tp[0] * mp[0];

					tp += Channels;
					mp += Channels;
				}

				op[0] = a0;
				op += Channels;
				ox++;
			}
		}

		unsafe void IConvolver.SharpenLine(byte* cstart, byte* ystart, byte* bstart, byte* ostart, int ox, int ow, int amt, int thresh, bool gamma)
		{
			float famt = amt * 0.01f;
			float threshold = (float)thresh / byte.MaxValue;

			float* ip = (float*)cstart + ox * Channels, yp = (float*)ystart + ox, bp = (float*)bstart, op = (float*)ostart;
			float* ipe = ip + ow * Channels - VectorF.Count;

			var vmin = VectorF.Zero;
			var vthresh = new VectorF(threshold > 0f ? threshold : -1f);
			var vamt = new VectorF(famt);
			float fmin = vmin[0];

			while (ip <= ipe)
			{
				var vd = Unsafe.ReadUnaligned<VectorF>(yp) - Unsafe.ReadUnaligned<VectorF>(bp);
				if (thresh > 0)
				{
					var sm = Vector.GreaterThan(Vector.Abs(vd), vthresh);
					vd = Vector.ConditionalSelect(sm, vd, vmin);
				}
				vd *= vamt;

				var v0 = Unsafe.ReadUnaligned<VectorF>(ip);

				if (gamma)
				{
					v0 = Vector.SquareRoot(Vector.Max(v0, vmin));
					v0 = Vector.Max(v0 + vd, vmin);
					v0 *= v0;
				}
				else
				{
					v0 += vd;
				}

				Unsafe.WriteUnaligned(op, v0);

				ip += VectorF.Count * Channels;
				op += VectorF.Count * Channels;
				yp += VectorF.Count;
				bp += VectorF.Count;
			}

			ipe += VectorF.Count;
			while (ip < ipe)
			{
				float dif = *yp++ - *bp++;
				float c0 = *ip;

				if (threshold == 0 || Math.Abs(dif) > threshold)
				{
					dif *= famt;

					if (gamma)
					{
						c0 = MathUtil.MaxF(c0, fmin).Sqrt();
						c0 = MathUtil.MaxF(c0 + dif, fmin);
						c0 *= c0;
					}
					else
					{
						c0 += dif;
					}
				}

				*op = c0;

				ip += Channels;
				op += Channels;
			}
		}
	}
}
