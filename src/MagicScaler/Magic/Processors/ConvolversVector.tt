<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#
procDef[] ta = {
	new procDef {
		name = "4Chan",
		vtype = "F",
		channels = 4,
		colors = 4,
		sharpen = true,
		xUnroll = 4,
		yUnroll = 4
	},
	new procDef {
		name = "3Chan",
		vtype = "4",
		channels = 3,
		colors = 3,
		xUnroll = 3,
		yUnroll = 0
	},
	new procDef {
		name = "3XChan",
		vtype = "F",
		channels = 4,
		colors = 3,
		sharpen = true,
		xUnroll = 4,
		yUnroll = 4
	},
	/*new procDef {
		name = "2Chan",
		vtype = "4",
		channels = 2,
		colors = 2,
		xUnroll = 2,
		yUnroll = 2
	},*/
	new procDef {
		name = "1Chan",
		vtype = "F",
		channels = 1,
		colors = 1,
		sharpen = true,
		xUnroll = 1,
		yUnroll = 1
	}
};
#>
//------------------------------------------------------------------------------
//	<auto-generated>
//		This code was generated from a template.
//		Manual changes to this file will be overwritten if the code is regenerated.
//	</auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Numerics;
using System.Runtime.CompilerServices;

using VectorF = System.Numerics.Vector<float>;

namespace PhotoSauce.MagicScaler
{
<#
foreach (var t in ta) {
	if (t != ta[0]) WriteLine(null);
#>
	internal sealed class Convolver<#= t.name #>Float : IConvolver
	{
<#
if (t.vtype != "F") {
#>
		private const int <#= t.vcnt #> = <#= t.vtype #>;

<#
}
#>
		private const int Channels = <#= t.channels #>;

		public static readonly Convolver<#= t.name #>Float Instance = new Convolver<#= t.name #>Float();

		private Convolver<#= t.name #>Float() { }

		int IConvolver.Channels => Channels;
		int IConvolver.MapChannels => Channels;

		unsafe void IConvolver.ConvolveSourceLine(byte* istart, byte* tstart, int cb, byte* mapxstart, int smapx, int smapy)
		{
			float* tp = (float*)tstart, tpe = (float*)(tstart + cb);
			float* pmapx = (float*)mapxstart;
			int kstride = smapx * Channels;
			int tstride = smapy * <#= t.channels == 3 ? "4" /* 3Chan to 3XChan x-over */ : "Channels" #>;
<#
if (t.channels == 1) {
#>

			var m0 = VectorF.One;
<#
}
#>

			while (tp < tpe)
			{
				int ix = *(int*)pmapx++;
				float* ip = (float*)istart + ix * Channels, ipe = ip + kstride;
				float* mp = pmapx;
				pmapx += kstride;

				float a0<# for (int i = 1; i < t.colors; i++) { #>, a<#= i #><# } #>;

				if (kstride >= <#= t.xUnrollIncr #>)
				{
					Vector<#= t.vtype #> av0 = Vector<#= t.vtype #>.Zero<# for (int i = 1; t.channels == 3 && i < t.colors; i++) { #>, av<#= i #> = av0<# } #>;
					ipe -= <#= t.xUnrollIncr #>;

					do
					{
<#
for (int i = 0; i < t.xUnroll; i++) {
#>
						var iv<#= i #> = Unsafe.ReadUnaligned<Vector<#= t.vtype #>>(ip<#= i != 0 ? $" + {t.vcnt}{(i > 1 ? $" * {i}" : "")}" : "" #>);
<#
}
#>
						ip += <#= t.xUnrollIncr #>;

<#
for (int i = 0; i < t.xUnroll; i++) {
#>
						var mv<#= i #> = Unsafe.ReadUnaligned<Vector<#= t.vtype #>>(mp<#= i != 0 ? $" + {t.vcnt}{(i > 1 ? $" * {i}" : "")}" : "" #>);
<#
}
#>
						mp += <#= t.xUnrollIncr #>;

<#
for (int i = 0; i < t.xUnroll; i++) {
#>
						av<#= t.channels == 3 ? i : 0 #> += iv<#= i #> * mv<#= i #>;
<#
}
#>
					} while (ip <= ipe);

					ipe += <#= t.xUnrollIncr #>;

<#
if (t.channels == 4) {
	for (int i = 0; i < t.colors; i++) {
#>
					a<#= i #> = av0[<#= i #>];
<#
	}
#>

					if (VectorF.Count == 8)
					{
<#
	for (int i = 0; i < t.colors; i++) {
#>
						a<#= i #> += av0[<#= i + 4 #>];
<#
	}
#>
					}
<#
} else if (t.channels == 3) {
#>
					a0 = av0.X + av0.W + av1.Z + av2.Y;
					a1 = av0.Y + av1.X + av1.W + av2.Z;
					a2 = av0.Z + av1.Y + av2.X + av2.W;
<#
} else if (t.channels == 2) {
#>
					a0 = av0.X + av0.Z;
					a1 = av0.Y + av0.W;
<#
} else {
	for (int i = 0; i < t.colors; i++) {
#>
					a<#= i #> = Vector.Dot(a<#= t.channels == 3 ? $"t{i}" : "v0" #>, m<#= t.channels == 3 ? 0 : i #>);
<#
	}
}
#>
				}
				else
				{
					a0<# for (int i = 1; i < t.colors; i++) { #> = a<#= i #><# } #> = 0f;
				}

				while (ip < ipe)
				{
<#
for (int i = 0; i < t.colors; i++) {
#>
					a<#= i #> += ip[<#= i #>] * mp[<#= i #>];
<#
}
#>

					ip += Channels;
					mp += Channels;
				}

<#
for (int j = 0; j < t.colors; j++) {
#>
				tp[<#= j #>] = a<#= j #>;
<#
}
#>
				tp += tstride;
			}
		}

<#
if (t.yUnroll > 0) {
#>
		unsafe void IConvolver.WriteDestLine(byte* tstart, byte* ostart, int ox, int ow, byte* pmapy, int smapy)
		{
			float* op = (float*)ostart;
			int xc = ox + ow, tstride = smapy * Channels;
<#
if (t.channels == 1) {
#>

			var m0 = VectorF.One;
<#
}
#>

			while (ox < xc)
			{
				float* tp = (float*)tstart + ox * tstride, tpe = tp + tstride;
				float* mp = (float*)pmapy;

				float a0<# for (int i = 1; i < t.colors; i++) { #>, a<#= i #><# } #>;

				if (tstride >= <#= t.yUnrollIncr #>)
				{
					Vector<#= t.vtype #> av0 = Vector<#= t.vtype #>.Zero<# for (int i = 1; t.channels == 3 && i < t.colors; i++) { #>, av<#= i #> = av0<# } #>;
					tpe -= <#= t.yUnrollIncr #>;

					do
					{
<#
for (int i = 0; i < t.yUnroll; i++) {
#>
						var tv<#= i #> = Unsafe.ReadUnaligned<Vector<#= t.vtype #>>(tp<#= i != 0 ? $" + {t.vcnt}{(i > 1 ? $" * {i}" : "")}" : "" #>);
<#
}
#>
						tp += <#= t.yUnrollIncr #>;

<#
for (int i = 0; i < t.yUnroll; i++) {
#>
						var mv<#= i #> = Unsafe.ReadUnaligned<Vector<#= t.vtype #>>(mp<#= i != 0 ? $" + {t.vcnt}{(i > 1 ? $" * {i}" : "")}" : "" #>);
<#
}
#>
						mp += <#= t.yUnrollIncr #>;

<#
for (int i = 0; i < t.yUnroll; i++) {
#>
						av<#= t.channels == 3 ? i : 0 #> += tv<#= i #> * mv<#= i #>;
<#
}
#>
					} while (tp <= tpe);

					tpe += <#= t.yUnrollIncr #>;

<#
if (t.channels == 4) {
	for (int i = 0; i < t.colors; i++) {
#>
					a<#= i #> = av0[<#= i #>];
<#
	}
#>

					if (VectorF.Count == 8)
					{
<#
	for (int i = 0; i < t.colors; i++) {
#>
						a<#= i #> += av0[<#= i + 4 #>];
<#
	}
#>
					}
<#
} else if (t.channels == 3) {
#>
					a0 = av0.X + av0.W + av1.Z + av2.Y;
					a1 = av0.Y + av1.X + av1.W + av2.Z;
					a2 = av0.Z + av1.Y + av2.X + av2.W;
<#
} else if (t.channels == 2) {
#>
					a0 = av0.X + av0.Z;
					a1 = av0.Y + av0.W;
<#
} else {
	for (int i = 0; i < t.colors; i++) {
#>
					a<#= i #> = Vector.Dot(a<#= t.channels == 3 ? $"t{i}" : "v0" #>, m<#= t.channels == 3 ? 0 : i #>);
<#
	}
}
#>
				}
				else
				{
					a0<# for (int i = 1; i < t.colors; i++) { #> = a<#= i #><# } #> = 0f;
				}

				while (tp < tpe)
				{
<#
	for (int i = 0; i < t.colors; i++) {
#>
					a<#= i #> += tp[<#= i #>] * mp[<#= i #>];
<#
	}
#>

					tp += Channels;
					mp += Channels;
				}

<#
for (int j = 0; j < t.colors; j++) {
#>
				op[<#= j #>] = a<#= j #>;
<#
}
#>
				op += Channels;
				ox++;
			}
		}
<#
} else {
#>
		unsafe void IConvolver.WriteDestLine(byte* tstart, byte* ostart, int ox, int ow, byte* pmapy, int smapy) => throw new NotImplementedException();
<#
}
#>

<#
//http://en.wikipedia.org/wiki/Unsharp_masking
if (t.sharpen) {
#>
		unsafe void IConvolver.SharpenLine(byte* cstart, byte* ystart, byte* bstart, byte* ostart, int ox, int ow, int amt, int thresh, bool gamma)
		{
			float famt = amt * 0.01f;
			float threshold = (float)thresh / byte.MaxValue;

			float* ip = (float*)cstart + ox * Channels, yp = (float*)ystart + ox, bp = (float*)bstart, op = (float*)ostart;
			float* ipe = ip + ow * Channels<#= t.channels == 1 ? " - VectorF.Count" : "" #>;

			var vmin = Vector<#= t.channels == 1 ? "F" : t.channels.ToString() #>.Zero;
<#
if (t.channels == 1) {
#>
			var vthresh = new VectorF(threshold > 0f ? threshold : -1f);
			var vamt = new VectorF(famt);
			float fmin = vmin[0];
<#
} else {
#>
			var vamt = new Vector4(famt);
			vamt.W = 0f;
<#
}
#>

<#
if (t.channels == 1) {
#>
			while (ip <= ipe)
			{
				var vd = Unsafe.ReadUnaligned<VectorF>(yp) - Unsafe.ReadUnaligned<VectorF>(bp);
				yp += VectorF.Count;
				bp += VectorF.Count;

				if (thresh > 0)
				{
					var sm = Vector.GreaterThan(Vector.Abs(vd), vthresh);
					vd = Vector.ConditionalSelect(sm, vd, vmin);
				}
				vd *= vamt;

				var v0 = Unsafe.ReadUnaligned<VectorF>(ip);
				ip += VectorF.Count * Channels;

				if (gamma)
				{
					v0 = Vector.SquareRoot(Vector.Max(v0, vmin));
					v0 = Vector.Max(v0 + vd, vmin);
					v0 *= v0;
				}
				else
				{
					v0 += vd;
				}

				Unsafe.WriteUnaligned(op, v0);
				op += VectorF.Count * Channels;
			}

			ipe += VectorF.Count;
<#
}
#>
			while (ip < ipe)
			{
				float dif = *yp++ - *bp++;
				<#= t.channels == 1 ? "float" : "var" #> c0 = <#= t.channels == 1 ? "*ip" : $"Unsafe.ReadUnaligned<Vector{t.channels}>(ip)" #>;
				ip += Channels;

				if (threshold == 0 || Math.Abs(dif) > threshold)
				{
					<#= t.channels == 1 ? "dif *= famt" : $"var vd = new Vector{t.channels}(dif) * vamt" #>;

					if (gamma)
					{
						c0 = <#= t.channels == 1 ? "MathUtil.MaxF(c0, fmin).Sqrt()" : $"Vector{t.channels}.SquareRoot(Vector{t.channels}.Max(c0, vmin))" #>;
						c0 = <#= t.channels == 1 ? "MathUtil.MaxF(c0 + dif, fmin)" : $"Vector{t.channels}.Max(c0 + vd, vmin)" #>;
						c0 *= c0;
					}
					else
					{
						c0 += <#= t.channels == 1 ? "dif" : "vd" #>;
					}
				}

				<#= t.channels == 1 ? "*op = c0" : "Unsafe.WriteUnaligned(op, c0)" #>;
				op += Channels;
			}
		}
<#
} else {
#>
		unsafe void IConvolver.SharpenLine(byte* cstart, byte* ystart, byte* bstart, byte* ostart, int ox, int ow, int amt, int thresh, bool gamma) => throw new NotImplementedException();
<#
}
#>
	}
<#
}
#>
}
<#+
class procDef
{
	public string name;
	public string vtype;
	public int channels;
	public int colors;
	public bool sharpen;
	public int xUnroll;
	public int yUnroll;

	public string vcnt => vtype == "F" ? "VectorF.Count" : $"Vector{vtype}Count";
	public string xUnrollIncr => vcnt + (xUnroll > 1 ? $" * {xUnroll}" : "");
	public string yUnrollIncr => vcnt + (yUnroll > 1 ? $" * {yUnroll}" : "");
}
#>